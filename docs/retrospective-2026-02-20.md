# 四阶段开发体系复盘与优化方案

**日期：** 2026-02-20
**案例：** 晚报金融数据推送功能（时间戳 + 期货API修复）
**总耗时：** 约 3 小时
**Token 消耗：** 约 112k / 200k（56%）

---

## 一、本次开发过程分析

### 1.1 时间分布（估算）

| 阶段 | 耗时 | 占比 | 主要活动 |
|------|------|------|----------|
| **概念层** | 15 分钟 | 8% | 需求确认、技术调研、方案对比 |
| **骨架层** | 120 分钟 | 67% | Bug调试、API测试、ECS验证、多次重试 |
| **血肉层** | 30 分钟 | 17% | 代码完善、邮件模板优化、文档更新 |
| **记忆固化层** | 15 分钟 | 8% | 更新 CLAUDE.md、ARCHITECTURE.md、Git提交 |
| **总计** | 180 分钟 | 100% | - |

### 1.2 Token 消耗分析

| 类型 | Token 数 | 占比 | 主要来源 |
|------|---------|------|----------|
| **文件读取** | ~25k | 22% | plan.md 反复读取、CLAUDE.md、README.md |
| **Bash 输出** | ~30k | 27% | AKShare 进度条、SSH 错误重试、Docker 日志 |
| **工具调用** | ~20k | 18% | Git 操作、文件编辑、rsync 同步 |
| **系统提示** | ~15k | 13% | Git 规范、Bash 安全提示、工具说明 |
| **对话内容** | ~22k | 20% | 用户消息、助手回复、思考过程 |
| **总计** | ~112k | 100% | - |

---

## 二、速度瓶颈分析

### 2.1 流程层面的问题 ⚠️

#### 问题 1：骨架层过度验证（耗时占比 67%）

**现象：**
- 本应"粗糙"的骨架层，却做了大量调试工作
- 测试了 3 个不同的期货 API
- 创建了 5 个测试脚本（test_alternative_futures_api.py、debug_futures_api.py、test_new_futures_impl.py 等）
- 反复在 ECS 上验证，每次都要重建 Docker 镜像

**根本原因：**
- 用户要求"必须在骨架层解决期货数据问题"
- 骨架层和血肉层的边界不清晰

**影响：**
- 骨架层耗时 120 分钟，占总时间 67%
- 本应快速验证核心假设，却陷入细节调试

#### 问题 2：阶段确认过于频繁

**现象：**
- 概念层 → 骨架层：等待用户确认
- 骨架层 → 血肉层：等待用户确认
- 血肉层 → 记忆固化层：等待用户确认

**影响：**
- 每次确认可能等待数分钟到数十分钟
- 打断工作流程，降低连续性

#### 问题 3：文档维护过于详细

**现象：**
- plan.md 记录了所有验证过程（987 行）
- 包含大量重复的"已完成"、"待执行"标记
- 每个阶段都写详细的总结报告

**影响：**
- 文档维护耗时约 30 分钟
- plan.md 被读取和追加 10+ 次

### 2.2 技术层面的问题 ⚠️

#### 问题 1：SSH 连接不稳定导致重试

**现象：**
```
Connection closed by 8.155.155.125 port 22
rsync: Connection closed
scp: Connection closed
```

**统计：**
- SSH 失败次数：15+
- rsync 失败次数：8+
- 每次失败需要重试 1-3 次

**影响：**
- 累计浪费时间约 20 分钟
- Token 浪费约 5k（错误输出）

#### 问题 2：Docker 重建次数过多

**现象：**
- Docker build 执行次数：6 次
- Docker restart 执行次数：10+ 次

**根本原因：**
- 代码变更后必须重建镜像
- 没有使用卷挂载实现热更新

**影响：**
- 每次重建耗时 30-60 秒
- 累计浪费时间约 15 分钟

#### 问题 3：测试输出冗余

**现象：**
AKShare 进度条输出：
```
  0%|          | 0/58 [00:00<?, ?it/s]
  2%|▏         | 1/58 [00:01<01:06,  1.17s/it]
  ...
100%|██████████| 58/58 [01:08<00:00,  1.15s/it]
```

**影响：**
- 单次测试输出 3000+ 字符
- 累计消耗 Token 约 8k

---

## 三、成本浪费分析

### 3.1 Token 浪费点

| 浪费点 | 估算 Token | 优化空间 |
|--------|-----------|----------|
| **plan.md 反复读取** | ~8k | 70% - 使用缓存或增量更新 |
| **AKShare 进度条输出** | ~8k | 90% - 使用 --quiet 或重定向 |
| **SSH 错误重试** | ~5k | 80% - 优化网络或批量执行 |
| **Git 长系统提示** | ~4k | 50% - 简化提示或使用模板 |
| **重复的文件读取** | ~5k | 60% - 一次性读取完整文件 |
| **冗长的验证总结** | ~6k | 40% - 使用模板化输出 |
| **总计** | ~36k | **可节省约 60% 成本** |

### 3.2 时间浪费点

| 浪费点 | 估算时间 | 优化空间 |
|--------|----------|----------|
| **SSH 连接重试** | 20 分钟 | 80% - 使用批量脚本或本地验证 |
| **Docker 重复重建** | 15 分钟 | 90% - 使用卷挂载或本地开发 |
| **过度的骨架层调试** | 40 分钟 | 60% - 明确骨架层边界 |
| **阶段确认等待** | 10 分钟 | 50% - 合并阶段或快速模式 |
| **详细文档维护** | 20 分钟 | 50% - 简化 plan.md 或模板化 |
| **总计** | ~105 分钟 | **可节省约 65% 时间** |

---

## 四、根本原因总结

### 4.1 流程设计问题

1. **阶段划分过于严格**：
   - 每个阶段都要等待用户确认，打断工作流
   - 骨架层和血肉层的边界模糊，导致骨架层过度验证

2. **文档维护负担过重**：
   - plan.md 记录过于详细，维护成本高
   - 每个阶段都要写总结，重复劳动

3. **缺乏快速通道**：
   - 小功能也要走完整四阶段
   - 没有根据任务复杂度调整流程

### 4.2 技术实现问题

1. **远程验证依赖性过强**：
   - 每次代码变更都要部署到 ECS 验证
   - SSH 不稳定导致频繁重试

2. **Docker 使用低效**：
   - 代码变更需要重建镜像
   - 没有利用卷挂载实现热更新

3. **测试输出未过滤**：
   - AKShare 进度条输出大量冗余信息
   - 没有使用 grep 或 --quiet 过滤

---

## 五、优化方案

### 5.1 流程优化：三模式分级开发

#### 模式 1：快速模式（小功能/Bug修复）⚡

**适用场景：**
- 明确的小需求（如添加字段、修复 Bug）
- 文档更新、配置调整
- 预计耗时 < 30 分钟

**流程：**
```
直接实现 → 本地测试 → 文档更新 → Git 提交
```

**验收标准：**
- 功能可用即可
- 简化文档更新（仅更新 CLAUDE.md 变更日志）

**预期收益：**
- 时间节省 60%（30 分钟 → 12 分钟）
- Token 节省 70%（20k → 6k）

---

#### 模式 2：标准模式（中等功能）🔧

**适用场景：**
- 新功能开发
- 功能增强
- 预计耗时 30-120 分钟

**流程：**
```
快速调研（10分钟）→ 骨架验证 + 代码完善（合并）→ 记忆固化
```

**关键改进：**
1. **概念层精简**：只做核心假设验证，5-10 分钟
2. **骨架层 + 血肉层合并**：边验证边完善，不追求完美
3. **本地优先验证**：减少 ECS 部署次数
4. **简化文档**：plan.md 只记录关键决策

**验收标准：**
- 核心功能完整
- 代码质量良好
- 文档清晰

**预期收益：**
- 时间节省 50%（120 分钟 → 60 分钟）
- Token 节省 50%（60k → 30k）

---

#### 模式 3：完整模式（大功能/架构变更）🏗️

**适用场景：**
- 架构变更
- 复杂功能（涉及 5+ 文件）
- 高风险改动
- 预计耗时 > 120 分钟

**流程：**
```
概念层（深度调研）→ 骨架层（最小验证）→ 血肉层（完善）→ 记忆固化
```

**保持不变：**
- 每个阶段都要用户确认
- 详细的 plan.md 记录
- 完整的文档更新

**适用于：**
- 本次 HTTPS 配置
- 英文新闻源接入
- 未来的架构重构

---

### 5.2 技术优化：提升工具效率

#### 优化 1：本地开发优先 🏠

**现状问题：**
- 每次代码变更都要 rsync 到 ECS
- SSH 不稳定导致频繁失败

**优化方案：**
```bash
# 1. 本地 Docker Compose 开发环境
docker-compose -f docker-compose.dev.yml up

# 2. 代码卷挂载（热更新）
volumes:
  - ./backend:/app/backend:ro  # 只读挂载
  - ./scripts:/app/scripts

# 3. 本地验证通过后一次性部署
./scripts/deploy-to-ecs.sh
```

**预期收益：**
- 减少 SSH 重试次数：15+ → 2-3
- 节省时间：20 分钟 → 5 分钟
- Token 节省：5k → 1k

---

#### 优化 2：批量 SSH 执行 📦

**现状问题：**
- 单命令 SSH 执行，连接频繁
- 每次连接都可能失败

**优化方案：**
```bash
# 使用 heredoc 批量执行
ssh root@ECS << 'ENDSSH'
  cd /opt/news-bot
  docker compose build app
  docker compose up -d app
  docker compose exec -T app python scripts/test.py
ENDSSH

# 或创建一次性部署脚本
cat > /tmp/deploy.sh << 'EOF'
#!/bin/bash
cd /opt/news-bot
git pull
docker compose build app
docker compose up -d app
EOF

scp /tmp/deploy.sh root@ECS:/tmp/
ssh root@ECS 'bash /tmp/deploy.sh'
```

**预期收益：**
- SSH 连接次数：15+ → 3-5
- 节省时间：15 分钟 → 5 分钟

---

#### 优化 3：过滤冗余输出 🔇

**现状问题：**
- AKShare 进度条输出 3000+ 字符
- Docker 日志冗长

**优化方案：**
```bash
# 1. 使用环境变量禁用进度条
export PYTHONUNBUFFERED=1
export TQDM_DISABLE=1

# 2. Grep 过滤关键信息
python test.py 2>&1 | grep -E "(成功|失败|错误|✅|❌)"

# 3. 重定向到文件，只输出摘要
python test.py > /tmp/output.log 2>&1
echo "测试完成，详细日志：/tmp/output.log"
tail -20 /tmp/output.log
```

**预期收益：**
- Token 节省：8k → 1k
- 输出更清晰易读

---

#### 优化 4：智能文件读取 📖

**现状问题：**
- plan.md 被读取 10+ 次
- 每次都读取完整文件

**优化方案：**
```python
# 1. 使用 offset/limit 增量读取
Read(file_path="plan.md", offset=900, limit=50)  # 只读新增部分

# 2. 使用 Bash 追加而非 Read + Edit
cat >> plan.md << 'EOF'
新增内容
EOF

# 3. 缓存已读内容（在助手侧）
# 第一次读取后，后续只读新增部分
```

**预期收益：**
- Token 节省：8k → 2k

---

### 5.3 文档优化：精简 plan.md

#### 当前 plan.md 问题

**文件大小：** 987 行，~50KB
**问题：**
- 记录了所有验证过程（包括失败的尝试）
- 大量重复的"已完成"/"待执行"标记
- 详细的代码示例和输出

#### 优化方案：精简版 plan.md

**新结构：**
```markdown
# Plan: [功能名称]

## 状态：[当前阶段]

## 核心决策
- 决策 1：XXX（理由）
- 决策 2：XXX（理由）

## 技术要点
- 要点 1
- 要点 2

## 任务清单
- [x] 任务 1
- [ ] 任务 2

## 验收标准
- [ ] 标准 1
- [ ] 标准 2

## 遗留问题
- 问题 1：XXX（计划：XXX）
```

**对比：**
| 项目 | 当前版本 | 精简版本 | 节省 |
|------|---------|---------|------|
| 文件大小 | 987 行 | ~100 行 | 90% |
| 维护时间 | 20 分钟 | 5 分钟 | 75% |
| Token 消耗 | 8k | 2k | 75% |

---

### 5.4 成本优化：模型分级使用

#### 当前问题
- 所有任务都用 Sonnet 4.5
- 简单任务（Git 提交、文档更新）也用高成本模型

#### 优化方案

| 任务类型 | 当前模型 | 优化模型 | 成本节省 |
|---------|---------|---------|---------|
| 代码实现 | Sonnet 4.5 | Sonnet 4.5 | 0% |
| 技术调研 | Sonnet 4.5 | Sonnet 4.5 | 0% |
| 文档更新 | Sonnet 4.5 | Haiku | 95% |
| Git 提交 | Sonnet 4.5 | Haiku | 95% |
| 测试脚本 | Sonnet 4.5 | Haiku | 95% |
| 配置文件 | Sonnet 4.5 | Haiku | 95% |

**预期收益：**
- 总体成本节省约 30-40%

---

## 六、优化后的开发流程对比

### 本次开发（原流程）

```
概念层（15分钟）
  ↓ [等待确认]
骨架层（120分钟）- 包含大量调试和 ECS 验证
  ↓ [等待确认]
血肉层（30分钟）
  ↓ [等待确认]
记忆固化（15分钟）
  ↓
总耗时：180 分钟
Token：112k
```

### 优化后（标准模式）

```
快速调研（10分钟）- 本地验证核心假设
  ↓
实现 + 测试（40分钟）- 本地开发，一次性部署
  ↓
记忆固化（10分钟）- 简化文档
  ↓
总耗时：60 分钟（节省 67%）
Token：35k（节省 69%）
```

---

## 七、具体优化建议

### 7.1 立即可执行的优化（本周）

1. **创建本地开发环境** ⭐⭐⭐
   ```bash
   # docker-compose.dev.yml
   # 代码卷挂载，支持热更新
   ```

2. **创建 ECS 批量部署脚本** ⭐⭐⭐
   ```bash
   # scripts/deploy-to-ecs.sh
   # 一次性同步代码、重建、重启、测试
   ```

3. **优化测试输出** ⭐⭐
   ```bash
   # 禁用 AKShare 进度条
   export TQDM_DISABLE=1
   ```

4. **精简 plan.md 模板** ⭐⭐
   - 创建精简模板
   - 只记录关键决策

### 7.2 中期优化（本月）

1. **实施三模式分级开发**
   - 更新 CLAUDE.md 开发规范
   - 明确各模式适用场景

2. **创建快速通道流程**
   - 小功能跳过概念层
   - 减少阶段确认次数

3. **建立文档模板库**
   - 验收总结模板
   - 变更日志模板

### 7.3 长期优化（下月）

1. **引入模型分级使用**
   - 评估 Haiku 用于简单任务
   - 建立任务-模型映射规则

2. **优化工具链**
   - 研究 Claude Code 的自动化能力
   - 探索 CI/CD 集成

3. **建立成本监控**
   - 记录每次开发的 Token 消耗
   - 优化高成本环节

---

## 八、预期收益总结

### 时间收益

| 场景 | 原耗时 | 优化后 | 节省 |
|------|--------|--------|------|
| 小功能（如本次） | 180 分钟 | 60 分钟 | **67%** |
| 中等功能 | 240 分钟 | 120 分钟 | **50%** |
| 大功能 | 360 分钟 | 300 分钟 | **17%** |

### 成本收益

| 场景 | 原 Token | 优化后 | 节省 |
|------|----------|--------|------|
| 小功能 | 112k | 35k | **69%** |
| 中等功能 | 150k | 60k | **60%** |
| 大功能 | 250k | 180k | **28%** |

### 综合收益

假设每月开发：
- 小功能：10 次
- 中等功能：3 次
- 大功能：1 次

**原耗时：** 10×180 + 3×240 + 1×360 = 2880 分钟（48 小时）
**优化后：** 10×60 + 3×120 + 1×300 = 1260 分钟（21 小时）
**节省时间：** 27 小时/月（**56%**）

**原成本：** 10×112k + 3×150k + 1×250k = 1820k tokens
**优化后：** 10×35k + 3×60k + 1×180k = 710k tokens
**节省成本：** 1110k tokens/月（**61%**）

---

## 九、行动计划

### 本周行动（2026-02-20 ~ 2026-02-26）

- [ ] **Day 1**：创建本地开发环境（docker-compose.dev.yml）
- [ ] **Day 2**：创建 ECS 批量部署脚本
- [ ] **Day 3**：优化测试输出（禁用进度条）
- [ ] **Day 4**：创建精简版 plan.md 模板
- [ ] **Day 5**：更新 CLAUDE.md 添加三模式开发规范

### 验证标准

下次开发时验证：
- [ ] 本地开发环境可用，无需频繁部署 ECS
- [ ] SSH 连接次数减少 70%
- [ ] Token 消耗减少 50%
- [ ] 开发时间缩短 50%

---

## 十、总结

### 核心问题

1. **流程过于严格** - 小功能也要走完整四阶段
2. **远程验证依赖** - SSH 不稳定导致大量重试
3. **文档维护负担** - plan.md 过于详细
4. **成本控制粗放** - 未区分任务复杂度

### 核心方案

1. **三模式分级开发** - 根据任务复杂度选择流程
2. **本地开发优先** - 减少 ECS 部署次数
3. **精简文档维护** - 只记录关键决策
4. **智能工具使用** - 批量执行、过滤输出、模型分级

### 预期效果

- **时间节省：** 50-67%
- **成本节省：** 60-69%
- **开发体验：** 更流畅、更高效
- **文档质量：** 更清晰、更聚焦

---

**下一步：** 等待用户确认优化方案后，立即执行本周行动计划。
